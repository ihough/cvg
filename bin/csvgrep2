#!/usr/bin/env ruby

require 'csv'
require 'to_regexp'
require 'active_support/core_ext'

class Csvgrep2
  class << self
    def parse(argv)
      options = []
      input_paths = []

      option_k = nil
      argv.each do |arg|
        if option_k
          options << [option_k, arg]
          option_k = nil
        elsif arg.start_with?('--')
          option_k = arg[2..-1]
        else
          input_paths << arg
        end
      end

      [ input_paths, options ]
    end
  end

  class Test
    attr_reader :k
    attr_reader :arg
    def initialize(k, arg)
      @k = k
      @arg = arg
    end
  end

  class Present < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'present'
      end
    end
    def pass?(row)
      row.fetch(arg).to_s.present?
    end
  end

  class Missing < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'missing'
      end
    end
    def pass?(row)
      row.fetch(arg).to_s.strip.length == 0
    end
  end

  class Regex < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'regex'
      end
    end
    def pass?(row)
      !!(row.fetch(col).to_s =~ regex)
    end
    def col
      @col ||= CSV.parse_line(arg)[0]
    end
    def regex
      @regex ||= CSV.parse_line(arg)[1].to_regexp(detect: true) or raise("#{arg.inspect} doesn't have a valid regex")
    end
  end

  TESTS = [Present, Missing, Regex]

  attr_reader :argv
  attr_reader :options
  attr_reader :input_paths

  def initialize(argv)
    @argv = argv
    @input_paths, @options = Csvgrep2.parse argv
  end

  def perform
    output_headers

    each_input_row do |row|
      if tests.all? { |t| t.pass?(row) }
        output_row row
      end
    end

    close_output
  end

  private

  def each_input_row
    input_paths.each do |path|
      CSV.foreach(path, headers: :first_row) do |row|
        yield row.to_hash
      end
    end
  end

  def tests
    memo = []
    options.each do |k, v|
      TESTS.each do |test_class|
        if test = test_class.accept(k, v)
          memo << test
        end
      end
    end
    memo
  end

  def output_row(row)
    output_f.puts row.values_at(*headers).to_csv
  end

  def output_headers
    output_f.puts headers.to_csv
  end

  def output_f
    @output_f ||= $stdout
  end

  def close_output
    output_f.close
  end

  def headers
    @headers ||= input_paths.map do |path|
      CSV.parse_line(File.open(path) { |f| f.gets })
    end.flatten.uniq
  end


end

Csvgrep2.new(ARGV).perform
