#!/usr/bin/env ruby

require 'csv'
require 'to_regexp'
require 'active_support/core_ext'

class Csvgrep2
  class << self
    def parse(argv)
      options = []
      input_paths = []

      option_k = nil
      argv.each do |arg|
        if option_k
          options << [option_k, arg]
          option_k = nil
        elsif arg.start_with?('--')
          option_k = arg[2..-1]
        else
          input_paths << arg
        end
      end

      [ input_paths, options ]
    end
  end

  class Test
    attr_reader :k
    attr_reader :arg
    def initialize(k, arg)
      @k = k
      @arg = arg
    end
    # only used sometimes
    def col
      @col ||= arg.split(':', 2)[0]
    end
  end

  class Present < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'present'
      end
    end
    def pass?(row)
      row.fetch(arg).to_s.present?
    end
  end

  class Missing < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'missing'
      end
    end
    def pass?(row)
      row.fetch(arg).to_s.strip.length == 0
    end
  end

  class Regex < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'regex'
      end
    end
    def pass?(row)
      !!(row.fetch(col).to_s =~ regex)
    end
    def regex
      @regex ||= arg.split(':', 2)[1].to_regexp(detect: true) or raise("#{arg.inspect} doesn't have a valid regex")
    end
  end

  class Value < Test
    class << self
      def accept(k, arg)
        new(k, arg) if k == 'value'
      end
    end
    def pass?(row)
      v = row.fetch(col).to_s
      values.include? v
    end
    def values
      @values ||= CSV.parse_line arg.split(':', 2)[1]
    end
  end

  class GreaterOrLesser < Test
    class << self
      def accept(k, arg)
        new(k, arg) if OPERATOR[k]
      end
      def numify(v, verify = false)
        case v
        when JUST_A_NUMBER
          v.to_f
        when NUMBER
          v.gsub(NUMBER_FLUFF, '').to_f
        else
          raise "#{v.inspect} not a number" if verify
        end
      end
    end
    OPERATOR = {
      'lt'  => :<,
      'lte' => :<=,
      'gt'  => :>,
      'gte' => :>=,
    }
    NUMBER = /\d/
    JUST_A_NUMBER = /\A-?[\d.]+\z/
    NUMBER_FLUFF = /[^\d.eE\+\-]+/
    def pass?(row)
      if v = GreaterOrLesser.numify(row.fetch(col))
        v.send(operator, threshold)
      end
    end
    def operator
      @operator ||= OPERATOR.fetch(k)
    end
    def threshold
      @threshold ||= GreaterOrLesser.numify arg, true
    end
  end

  TESTS = [Present, Missing, Regex, Value, GreaterOrLesser]

  attr_reader :argv
  attr_reader :options
  attr_reader :input_paths

  def initialize(argv)
    @argv = argv
    @input_paths, @options = Csvgrep2.parse argv
  end

  def perform
    output_headers

    each_input_row do |row|
      if tests.all? { |t| t.pass?(row) }
        output_row row
      end
    end

    close_output
  end

  private

  def each_input_row
    input_paths.each do |path|
      CSV.foreach(path, headers: :first_row) do |row|
        yield row.to_hash
      end
    end
  end

  def tests
    memo = []
    options.each do |k, v|
      TESTS.each do |test_class|
        if test = test_class.accept(k, v)
          memo << test
        end
      end
    end
    memo
  end

  def output_row(row)
    output_f.puts row.values_at(*headers).to_csv
  end

  def output_headers
    output_f.puts headers.to_csv
  end

  def output_f
    @output_f ||= $stdout
  end

  def close_output
    output_f.close
  end

  def headers
    @headers ||= input_paths.map do |path|
      CSV.parse_line(File.open(path) { |f| f.gets })
    end.flatten.uniq
  end


end

Csvgrep2.new(ARGV).perform
